# =============================================================================
# integration/spice_export.py — SPICE Netlist Generator
# =============================================================================
# Task 17 of Hardware-Faithful Simulator
#
# Generates LTspice-compatible netlists from component parameters.
# This bridges the physics engine to your existing LTspice co-simulation.
#
# Outputs:
#   1. PV receiver subcircuit (.cir) with physics-derived R, C_j, I_0
#   2. LED driver subcircuit
#   3. Complete system netlist for transient/AC analysis
# =============================================================================

import sys, os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from components.base import get_component
from integration.adapter import (
    compute_effective_responsivity, compute_received_power,
)


def pv_receiver_netlist(rx_part: str, led_part: str = 'OSRAM_LRW5SN',
                        distance_m: float = 0.325,
                        R_load: float = 1000.0,
                        I_drive_A: float = 0.350,
                        T: float = 300.0) -> str:
    """
    Generate LTspice .cir netlist for PV receiver equivalent circuit.

    Circuit topology:
        I_ph (current source) || D1 (diode) || C_j || R_shunt → R_load → GND

    All component values derived from physics.

    Args:
        rx_part: Receiver part number
        led_part: LED part number (for computing I_ph)
        distance_m: TX-RX distance
        R_load: Load resistance
        I_drive_A: LED drive current
        T: Temperature

    Returns:
        LTspice .cir netlist string
    """
    rx = get_component(rx_part)
    led = get_component(led_part)

    # Derived parameters
    R_eff = compute_effective_responsivity(led, rx, I_drive_A, T)
    P_rx = compute_received_power(led, rx, distance_m, I_drive_A, 0, T)
    I_ph = R_eff * P_rx
    C_j = rx.junction_capacitance(0, T)
    I_0 = rx.dark_current(T)
    dp = rx.derived_parameters(T)
    n_cells = dp.get('n_cells', 1)
    R_sh = dp.get('R_sh_ohm', getattr(rx, '_ds', {}).get('R_sh_ohm', 1e9))

    # Ideality factor for SPICE diode model
    n_ideality = 1.5
    V_T = 0.02585 * T / 300  # Thermal voltage

    netlist = f"""\
* =============================================================
* LiFi-PV Receiver — {rx_part}
* Generated by Hardware-Faithful Simulator
* =============================================================
* Setup: {led_part} → {distance_m}m → {rx_part}
* Temperature: {T} K
* R_load: {R_load} Ω
* I_drive: {I_drive_A*1e3:.0f} mA
* =============================================================
* DERIVED PARAMETERS:
*   R_eff = {R_eff:.4f} A/W
*   P_rx  = {P_rx*1e6:.2f} µW
*   I_ph  = {I_ph*1e6:.2f} µA
*   C_j   = {C_j*1e12:.1f} pF
*   I_0   = {I_0:.4e} A
*   R_sh  = {R_sh:.0f} Ω
*   n_cells = {n_cells}
* =============================================================

.temp {T - 273.15:.1f}

* Photocurrent source (signal modulated around DC bias)
* For OOK: I_ph switches between 0 and {I_ph*1e6:.2f} µA
I_ph PV_anode GND PULSE(0 {I_ph:.6e} 0 1n 1n {{0.5/freq}} {{1/freq}})
.param freq=100k

* Junction diode(s) — {n_cells} cells in series
"""
    # Model each cell as a diode
    for i in range(n_cells):
        node_a = f"PV_d{i}" if i > 0 else "PV_anode"
        node_c = f"PV_d{i+1}" if i < n_cells - 1 else "PV_cathode"
        netlist += f"D{i+1} {node_a} {node_c} PV_DIODE\n"

    netlist += f"""
.model PV_DIODE D(Is={I_0/n_cells:.4e} N={n_ideality} Cjo={C_j*1e12/n_cells:.2f}p Rs=0.1)

* Shunt resistance
R_shunt PV_anode PV_cathode {R_sh:.0f}

* Load resistance
R_load PV_cathode GND {R_load:.0f}

* Output voltage node
.meas TRAN V_out AVG V(PV_cathode)
.meas TRAN I_load AVG I(R_load)

* Analysis
.tran 0 {{10/freq}} 0 {{0.01/freq}}
.ac dec 100 1 100Meg

.backanno
.end
"""
    return netlist


def led_driver_netlist(led_part: str, I_drive_A: float = 0.350,
                       T: float = 300.0) -> str:
    """
    Generate LTspice netlist for LED driver circuit.

    Simple current-regulated driver with modulation input.
    """
    led = get_component(led_part)
    dp = led.derived_parameters(T)
    V_f = dp['V_f_V']
    P_opt = led.optical_power(I_drive_A, T)

    netlist = f"""\
* =============================================================
* LED Driver — {led_part}
* Generated by Hardware-Faithful Simulator
* =============================================================
* V_f = {V_f} V
* I_drive = {I_drive_A*1e3:.0f} mA
* P_opt = {P_opt*1e3:.1f} mW
* η_rad = {dp['eta_radiant']*100:.1f}%
* =============================================================

* Supply
V_supply VCC GND {V_f + 2:.1f}

* LED model (voltage source + series resistance)
V_led VCC LED_anode {V_f}
R_led LED_anode LED_mod {dp.get('R_s_ohm', 5):.1f}

* Modulation current source
* OOK: switches between I_bias and I_bias + I_mod
.param I_bias={I_drive_A/2:.4f}
.param I_mod={I_drive_A/2:.4f}
I_drive LED_mod GND PULSE({{I_bias}} {{I_bias+I_mod}} 0 1n 1n {{0.5/freq}} {{1/freq}})
.param freq=100k

.tran 0 {{10/freq}} 0 {{0.01/freq}}
.backanno
.end
"""
    return netlist


def system_netlist(led_part: str, rx_part: str,
                   distance_m: float = 0.325,
                   R_load: float = 1000.0,
                   I_drive_A: float = 0.350,
                   T: float = 300.0) -> str:
    """
    Complete system netlist with parameter header.

    Intended for co-simulation: Python drives the optical channel
    model, SPICE handles the electrical domains.
    """
    rx = get_component(rx_part)
    led = get_component(led_part)

    R_eff = compute_effective_responsivity(led, rx, I_drive_A, T)
    P_rx = compute_received_power(led, rx, distance_m, I_drive_A, 0, T)
    I_ph = R_eff * P_rx
    C_j = rx.junction_capacitance(0, T)
    I_0 = rx.dark_current(T)
    dp = rx.derived_parameters(T)
    R_sh = dp.get('R_sh_ohm', getattr(rx, '_ds', {}).get('R_sh_ohm', 1e9))
    n_cells = dp.get('n_cells', 1)

    netlist = f"""\
* =============================================================
* LiFi-PV COMPLETE SYSTEM NETLIST
* Generated by Hardware-Faithful Simulator
* =============================================================
* LED:      {led_part}
* Receiver: {rx_part}
* Distance: {distance_m} m
* Temp:     {T} K
* =============================================================
* LINK BUDGET:
*   P_tx  = {led.optical_power(I_drive_A, T)*1e3:.2f} mW
*   P_rx  = {P_rx*1e6:.2f} µW
*   R_eff = {R_eff:.4f} A/W
*   I_ph  = {I_ph*1e6:.2f} µA
* =============================================================

.param freq=100k
.param I_ph_dc={I_ph:.6e}
.temp {T - 273.15:.1f}

* --- PV RECEIVER ---
* Photocurrent (from optical channel model)
I_signal N_pv GND PULSE(0 {{I_ph_dc}} 0 1n 1n {{0.5/freq}} {{1/freq}})

* Junction equivalent circuit
"""
    for i in range(n_cells):
        na = f"N_d{i}" if i > 0 else "N_pv"
        nc = f"N_d{i+1}" if i < n_cells - 1 else "N_out"
        netlist += f"D{i+1} {na} {nc} CELL_DIODE\n"

    netlist += f"""
.model CELL_DIODE D(Is={I_0/n_cells:.4e} N=1.5 Cjo={C_j*1e12/n_cells:.2f}p)

R_shunt N_pv N_out {R_sh:.0f}
C_parasitic N_out GND 1p
R_load N_out GND {R_load:.0f}

* --- MEASUREMENTS ---
.meas TRAN V_pk PP V(N_out)
.meas TRAN V_avg AVG V(N_out)

* --- ANALYSIS ---
.tran 0 {{20/freq}} 0 {{0.01/freq}} startup
.ac dec 200 1 1G

.backanno
.end
"""
    return netlist


# =============================================================================
# SELF-TEST
# =============================================================================

def test_spice_export():
    print("=" * 70)
    print("SPICE NETLIST GENERATOR — TEST SUITE")
    print("=" * 70)
    passes = 0

    # --- PV receiver netlist ---
    print("\n1. PV RECEIVER NETLIST (KXOB25)")
    nl = pv_receiver_netlist('KXOB25-04X3F', 'OSRAM_LRW5SN', 0.325)
    assert 'KXOB25-04X3F' in nl
    assert '.model PV_DIODE' in nl
    assert 'R_load' in nl
    assert 'I_ph' in nl
    lines = nl.strip().split('\n')
    print(f"  Generated {len(lines)} lines")
    print(f"  Contains: diode model, photocurrent source, R_load, R_shunt")
    # Check physics values are embedded
    assert '798' in nl or '799' in nl  # C_j
    print("  Physics parameters embedded: ✓")
    passes += 1

    # --- LED driver ---
    print("\n2. LED DRIVER NETLIST")
    nl_led = led_driver_netlist('OSRAM_LRW5SN')
    assert 'OSRAM_LRW5SN' in nl_led
    assert 'V_supply' in nl_led
    lines_led = nl_led.strip().split('\n')
    print(f"  Generated {len(lines_led)} lines")
    passes += 1

    # --- System netlist ---
    print("\n3. COMPLETE SYSTEM NETLIST")
    nl_sys = system_netlist('OSRAM_LRW5SN', 'KXOB25-04X3F', 0.325)
    assert 'LINK BUDGET' in nl_sys
    assert '.tran' in nl_sys
    assert '.ac' in nl_sys
    lines_sys = nl_sys.strip().split('\n')
    print(f"  Generated {len(lines_sys)} lines")
    print(f"  Contains: link budget header, diodes, R_load, .tran, .ac")
    passes += 1

    # --- Swappability: different receiver → different netlist ---
    print("\n4. SWAPPABILITY (different netlists)")
    nl_bpw = pv_receiver_netlist('BPW34', 'OSRAM_LRW5SN', 0.325)
    # BPW34 has different C_j (70pF vs 799pF)
    assert '70' in nl_bpw or '69' in nl_bpw
    assert nl_bpw != nl
    print("  BPW34 netlist differs from KXOB25: ✓")
    passes += 1

    # --- Write sample to file ---
    print("\n5. WRITE SAMPLE NETLIST")
    outpath = '/home/claude/kxob25_receiver.cir'
    with open(outpath, 'w') as f:
        f.write(nl_sys)
    print(f"  Written to {outpath}")
    passes += 1

    print(f"\n{'=' * 70}")
    print(f"RESULTS: {passes} passed, 0 failed")
    print(f"{'=' * 70}")


if __name__ == '__main__':
    test_spice_export()
